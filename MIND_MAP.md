> **For AI Agents:** This mind map is your primary knowledge index. Read overview nodes [1-5] first, then follow links [N] to find what you need. Always reference node IDs. When you encounter bugs, document your attempts in relevant nodes. When you make changes, update outdated nodes immediatelyâ€”especially overview nodes since they're your springboard. Add new nodes only for genuinely new concepts. Keep it compact (20-50 nodes typical). The mind map wraps every task: consult it, rely on it, update it.

[1] **Repository Overview** - Rectangular Labs is a TypeScript Turborepo that combines multiple web apps and shared packages into one deployable system for SEO workflows, content operations, and marketing surfaces [2][4][5]. The current architecture centers on `apps/seo` for the product, `packages/api-seo` for oRPC endpoints and Cloudflare workflows, and `packages/db` for Drizzle schemas plus operations [6][9][11]. The strategy-first model is actively implemented in schema, routes, and workflows, with deeper design rationale tracked in the architecture doc [13][14][15][23].

[2] **Monorepo and Tooling Spine** - Workspace boundaries are declared in `pnpm-workspace.yaml` (`apps/*`, `packages/*`, `tooling/*`), and root scripts in `package.json` orchestrate build, dev, DB commands, lint, format, and type checks across the graph [1][22]. The stack uses `turbo`, `pnpm`, TypeScript 5, Biome, and Vitest, with dotenvx-based env management and Cloudflare-compatible app runtimes [21][22]. Package-level scripts generally compile with `tsc` or `tsup`, while app-level scripts decrypt env and run TanStack Start via Vite [4][5][6].

[3] **End-to-End Request/Data Flow** - Browser requests enter TanStack Start routes in each app, then API calls from app clients use `@rectangular-labs/api-seo/client` or server client helpers to hit `/api/rpc/*` [4][6][9]. The API layer validates input/output with ArkType, applies auth/org middleware, and delegates persistence to `packages/db/src/operations` helpers that return `Result` objects [10][12][18]. Async work is kicked to task/workflow providers and later polled through task status APIs, with results feeding strategy/content views and snapshots [14][15][16].

[4] **Application Surfaces and Routing** - The repo has three primary TanStack Start apps (`apps/seo`, `apps/www`, `apps/seo-www`) with file-based routing and generated route trees [1][6][7][8]. `apps/seo` contains authenticated organization/project routes, onboarding, content tabs, settings, strategy detail/list pages, and a gated links exchange page under nested `_authed` and `$param` folders [6][13]. `apps/www` and `apps/seo-www` serve marketing/docs/blog/legal content and separate brand narratives while still sharing workspace packages for UI and content plumbing [7][8][19].

[5] **Backend Service Architecture** - API behavior is composed from `packages/api-core` and domain-specific packages (`api-seo`, `api-user-vm`, `task`, `db`, integrations), giving a layered model of handlers, context, routes, operations, and workflow execution [1][9][10]. `api-core` provides reusable handler/link utilities for RPC, OpenAPI, WebSocket RPC, CORS, and request/response header plugins [9][18]. `api-seo` is the main domain API, while `task` and workflow bindings support long-running generation, planning, onboarding, and strategy execution [15][16][20].

[6] **SEO Product App (`apps/seo`)** - `apps/seo` is the operational UI for organizations and projects, with route groups for onboarding, dashboard/content, settings, strategies, and links exchange management [4][13][14]. API access is centralized in `apps/seo/src/lib/api.ts`, which chooses server or browser clients and integrates TanStack Query utilities for data fetching [3][9]. Content now supports both table-driven drawer details and a dedicated deep-link details route (`/$organizationSlug/$projectSlug/content/$draftId`), with shared rendering logic in `-components/content-display.tsx` so drawer/page experiences stay aligned [14][19]. Trend graph rendering for clicks/impressions/CTR/position is also centralized in `-components/snapshot-trend-chart.tsx` and reused by both content details and strategy detail surfaces to avoid duplicated chart logic. Top-keyword controls and visualization are now similarly shared via `-components/top-keywords.tsx`, with common metric/search/sort/page behavior used in both content details and strategy detail tabs. Server routes `/api/rpc/$` create per-request API context then dispatch to the shared RPC handler, making app and API boundaries explicit but colocated [9][10].

[7] **Main Marketing App (`apps/www`)** - `apps/www` is a broader marketing/docs/blog surface for Rectangular Labs, containing marketing routes, docs routes, and blog/RSS endpoints [4][19]. It shares the app/runtime conventions of the repo (TanStack Start + Vite + decrypted env local files) but is structurally content-centric rather than operations-centric [2][21]. This app acts as brand and documentation frontage that complements, but does not replace, product workflows in `apps/seo` [1][6].

[8] **SEO Marketing App (`apps/seo-www`)** - `apps/seo-www` is a dedicated marketing site for the SEO product with campaign-oriented landing routes, legal pages, referral paths, and blog/search endpoints [4][7]. Its route components are organized around narrative variants (founders/original/seo-experts) while still using shared workspace utilities and content patterns [19][21]. It should be kept aligned with product messaging as strategy-first UX evolves in the main app [6][13][23].

[9] **API Route Composition (`packages/api-seo`)** - `packages/api-seo/src/routes/index.ts` lazily composes route modules (`project`, `chat`, `task`, `content`, `strategy`, `integrations`, auth subroutes) into a single router tree [5][10]. Domain routes use `base`, `protectedBase`, and `withOrganizationIdBase` middleware chains, then validate with ArkType and DB-derived schemas [10][18]. The strategy route family now splits snapshot behavior into a dedicated sub-router (`routes/strategy.snapshot.ts`) nested under `strategy.snapshot`, while `routes/strategy.ts` keeps list/get/create/update/phase ownership [13][14][16].

[10] **API Context and Middleware** - `createApiContext` wires DB, auth handler, buckets, KV, scheduler, and workflow bindings into typed request context, then oRPC middleware enriches it with session/user and logging/async storage capabilities [5][9][16]. `protectedBase` enforces authenticated requests; `withOrganizationIdBase` additionally requires active organization and is reused across organization-scoped routes [9][14]. This context model keeps domain handlers thin and pushes shared concerns (auth/session headers/env wiring) into one place [3][18].

[11] **Database Schema Topology (`packages/db/src/schema`)** - Drizzle schema modules define auth and SEO tables, including projects, integrations, chat, content draft/published records, task runs, and the strategy table family [1][12][13]. The strategy schema set (`strategy`, `strategy_phase`, `strategy_phase_content`, `strategy_snapshot`, `strategy_snapshot_content`) is already present with relations and typed insert/select/update schemas [13][15][18]. Indexes and soft-delete filtering conventions support query patterns used by operations and route handlers [12][14].

[12] **Database Operations Pattern** - Data access is intentionally centralized in `packages/db/src/operations/**`, exporting cohesive helpers and returning `ok/err/safe` results from `@rectangular-labs/result` [3][11][18]. Strategy operations now include lightweight strategy detail retrieval (`getStrategyDetailsLite`) plus snapshot-series/content-series/latest-content/keyword-aggregation helpers consumed by `strategy.snapshot.*` endpoints, in addition to existing create/update/phase/snapshot write helpers [13][14][15]. This pattern keeps SQL/Drizzle complexity out of app routes and enforces consistent error handling boundaries before converting failures to `ORPCError`s [9][10].

[13] **Strategy Domain Model** - Strategy is the current domain backbone: a long-lived strategy holds motivation and goal, phases model execution slices, phase-content links tie drafts/plans to work items, and snapshots capture aggregate performance over time while delta values are derived from adjacent snapshots at read-time instead of persisted columns [11][12][14][15]. Status enums in schemas/parsers support suggestion-to-active lifecycle transitions and dismissal/observation states used by UI and workflows [14][18]. This model is codified in schema files and reflected in product routes (`.../strategies`) and onboarding components [4][6][23].

[14] **Strategy API Behaviors** - `packages/api-seo/src/routes/strategy.ts` implements CRUD/list/detail endpoints plus phase creation/update and validates organization ownership before mutations [9][10][13]. Strategy detail responses are now intentionally lightweight (`latest 2 snapshots` with aggregate+delta only) while snapshot-heavy data is fetched through nested endpoints: `strategy.snapshot.series`, `strategy.snapshot.content.list` (unsorted payload), and `strategy.snapshot.keywords.list`; content drawer details now live under `content.getDraftDetails`, and project-wide content overview rows are served by `content.listOverview` [6][9][11][12]. Creating or activating a strategy still triggers phase generation, and manual snapshot trigger now lives under the dedicated snapshot sub-router (`strategy.snapshot.create`) [15][16]. This route family remains both a mutation surface and a workflow/scheduler boundary, so regressions here directly affect adoption and metrics freshness [6][9][22].

[15] **Strategy Phase Generation Workflow (`strategy-phase-generation-workflow.ts`)** - The workflow loads project/strategy context, generates the next phase with tool-assisted analysis (GSC, DataForSEO, web, strategy tools), creates phase/content artifacts through DB operations, and includes prior phase history in generation context [11][12][13]. It supports repeated phase generation, aligns phase/content creation with current parser schema, triggers writer workflows for generated/updated drafts, and now queues the dedicated snapshot workflow instead of taking snapshots inline [14][16][18]. Phase `targetCompletionDate` computation uses shared utility `packages/core/src/strategy/compute-phase-target-completion-date.ts` so cadence math stays consistent across workflow and UI [18][23]. This file remains a critical implementation node for strategy-first execution [14][23].

[16] **Task and Workflow Orchestration** - `packages/api-seo/src/routes/task.ts` abstracts provider differences and exposes unified task creation/status responses, mapping Trigger.dev and Cloudflare workflow states into a shared status contract [3][5][14]. Workflow bindings include planner, writer, onboarding, strategy suggestions, strategy phase generation, and strategy snapshot generation; task polling resolves provider-specific execution details and typed outputs [9][15]. This layer decouples UI progress UX from execution backend choices while preserving typed contracts via core task schemas [6][18].

[17] **External Integrations** - Integration route modules (`integration.gsc`, `integration.github`, `integration.shopify`, webhook handlers) connect project data to external systems and feed content/strategy workflows [9][13][16]. `packages/google-apis` supplies GSC access used in strategy metrics gathering, while `packages/dataforseo` and other integration libraries support broader SEO signal ingestion [11][20]. Integration health and credential state are prerequisites for high-quality automation outcomes in onboarding and strategy execution [6][21].

[18] **Shared Schemas and Contracts (`packages/core`)** - `packages/core/src/schemas` holds ArkType schemas for task and strategy parsing, including cadence, statuses, snapshot types, and workflow IO contracts consumed by both API and workers [9][11][13]. Project publishing settings now explicitly include `participateInLinkExchange` so the Links page toggle persists through `project.update` and remains consistent with settings saves/default workspace provisioning [4][6][9]. Core now also contains shared strategy scheduling logic at `packages/core/src/strategy/compute-phase-target-completion-date.ts` with dedicated tests, reducing duplicate cadence/date logic across API and app layers [6][15][22]. This shared contract+logic layer keeps validation and behavior synchronized across apps, routes, DB schema typing, and workflow implementations [3][15][16]. Architectural convention discourages ad-hoc casting and favors explicit schema-driven typing, making this package a key safety rail [2][22].

[19] **Shared UI/Auth/Content Packages** - `packages/ui`, `packages/auth`, and `packages/content` supply reusable front-end components, auth flows, and content/blog utilities across the three apps [4][6][7]. `auth` integrates with API context/session middleware, while `content` powers blog/docs surfaces in marketing apps [10][7]. UI primitives now also include a responsive `PopoverTooltip` (`popover` on mobile, `tooltip` on desktop) used by content keyword detail affordances in the SEO app [6][14]. Reuse through these packages prevents duplicate implementation logic and keeps app-specific routes focused on orchestration and presentation [2][5].

[20] **Background Tasks Package (`packages/task`)** - `packages/task` contains Trigger.dev and crawling/search helpers (`trigger/*`, `crawlers/*`, `lib/ai-tools/*`) and exposes client utilities used by API task status logic [5][16][17]. Its responsibilities include site understanding and SEO-related asynchronous jobs that complement Cloudflare workflow-based execution [3][21]. This package is part of the broader execution substrate and should stay consistent with task input/output schemas in `packages/core` [18][22].

[21] **Environment and Deployment Model** - Env variables are managed with dotenvx (`.env`, `.env.local`, `.env.production`), and app dev scripts decrypt env into local files before running Vite/TanStack Start [2][6][8]. Cloudflare Workers/Wrangler runtime assumptions are embedded in API/workflow code (`cloudflare:workers`, workflow bindings), and DB access expects local Docker-backed PostgreSQL during development [5][11]. Deploy/build paths (`build`, `build:preview`, `build:production`) should be reflected in operational docs and onboarding for contributors [22][23].

[22] **Quality and Testing Bar** - Repository policy requires running `pnpm typecheck`, `pnpm lint`, and `pnpm format` after code changes, and these commands are orchestrated through Turbo at workspace scope [2][1]. Vitest is configured at the root with app-level test patterns, while package tests run via filtered workspace commands [6][20]. For any future architecture or workflow changes, update map nodes and add/adjust tests where behavior transitions are encoded (especially strategy and task status paths) [14][16][23].

[23] **Living Documentation and Evolution** - `strategy-architecture.md` captures the strategy-first design intent and remains the primary narrative reference for why schema/UI/workflow shifts are being made [13][15]. `AGENTS.md` mandates keeping `MIND_MAP.md` current, so architecture updates should include node edits and link rewiring in the same change set [1][22]. When implementation diverges from the strategy architecture doc, record the delta in this map and either update the design doc or annotate interim states here [11][24].

[24] **Current Gaps and Maintenance Notes** - This initial project map now exists but should be refined with commit-history nodes and subsystem deep dives when major refactors land, following the methodology in `PROJECT_MIND_MAPPING.md` [23][1]. Notable watch areas are strategy lifecycle edge cases, workflow idempotency, and alignment between marketing messaging (`apps/seo-www`) and implemented product capability (`apps/seo`) [8][14][15]. Any new top-level app/package or major routing/schema rewrite should trigger immediate updates to overview nodes [1-5] before adding specialized nodes [2][4][11].
