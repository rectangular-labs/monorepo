import { ORPCError } from "@orpc/client";
import { and, desc, eq, schema } from "@rectangular-labs/db";
import { type } from "arktype";
import { protectedBase } from "../context";
import { generateReply } from "../lib/ai";
import { formatMention } from "../lib/database/format-mention";
import { getProjectById } from "../lib/database/project";
import { getPromptById } from "../lib/database/prompt";

const list = protectedBase
  .route({ method: "GET", path: "/" })
  .input(type({ projectId: "string", mentionId: "string|undefined" }))
  .output(schema.projectMentionReplySelectSchema.array())
  .handler(async ({ context, input }) => {
    const { session } = context.session;
    if (!session.activeOrganizationId) {
      throw new ORPCError("BAD_REQUEST", { message: "Organization not found" });
    }
    const project = await getProjectById(
      input.projectId,
      session.activeOrganizationId,
    );
    if (!project.ok)
      throw new ORPCError("BAD_REQUEST", { message: project.error.message });
    const rows = await context.db.query.smProjectMentionReply.findMany({
      where: input.mentionId
        ? and(
            eq(schema.smProjectMentionReply.projectId, input.projectId),
            eq(schema.smProjectMentionReply.mentionId, input.mentionId),
          )
        : eq(schema.smProjectMentionReply.projectId, input.projectId),
      orderBy: desc(schema.smProjectMentionReply.createdAt),
    });
    return rows;
  });

const generate = protectedBase
  .route({ method: "POST", path: "/generate" })
  .input(
    type({
      projectId: "string",
      attributedKeywordId: "string",
      mentionId: "string",
    }),
  )
  .output(schema.projectMentionReplySelectSchema)
  .handler(async ({ context, input }) => {
    const { session } = context.session;
    if (!session.activeOrganizationId) {
      throw new ORPCError("BAD_REQUEST", { message: "Organization not found" });
    }

    const project = await getProjectById(
      input.projectId,
      session.activeOrganizationId,
    );
    if (!project.ok) {
      throw new ORPCError("BAD_REQUEST", { message: project.error.message });
    }
    const systemPromptOverride = project.value.currentReplyPromptId
      ? await getPromptById(project.value.currentReplyPromptId)
      : undefined;
    if (systemPromptOverride && !systemPromptOverride.ok) {
      throw new ORPCError("INTERNAL_SERVER_ERROR", {
        message: systemPromptOverride.error.message,
      });
    }
    const keywordMention =
      await context.db.query.smProjectKeywordMention.findFirst({
        where: (table, { eq, and }) =>
          and(
            eq(table.mentionId, input.mentionId),
            eq(table.projectId, input.projectId),
            eq(table.keywordId, input.attributedKeywordId),
          ),
        with: {
          mention: true,
        },
      });
    if (!keywordMention) {
      throw new ORPCError("BAD_REQUEST", { message: "Mention not found" });
    }
    const content = formatMention(keywordMention.mention);
    if (!content) {
      throw new ORPCError("BAD_REQUEST", {
        message: "Mention content is empty. Nothing to reply to.",
      });
    }
    const generationResult = await generateReply({
      mentionContent: content,
      systemPrompt: systemPromptOverride?.value?.prompt ?? null,
    });
    if (!generationResult.ok) {
      throw new ORPCError("INTERNAL_SERVER_ERROR", {
        message: generationResult.error.message,
      });
    }
    const { text, modelId } = generationResult.value;

    const [row] = await context.db
      .insert(schema.smProjectMentionReply)
      .values({
        projectId: input.projectId,
        mentionId: input.mentionId,
        attributedKeywordId: input.attributedKeywordId,
        isAutoGenerated: true,
        model: modelId,
        promptOverrideId: project.value.currentReplyPromptId,
        replyText: text,
      })
      .returning();
    if (!row) {
      throw new ORPCError("INTERNAL_SERVER_ERROR", {
        message: "Failed to generate reply",
      });
    }
    return row;
  });

const approve = protectedBase
  .route({ method: "POST", path: "/{id}/approve" })
  .input(type({ id: "string", projectId: "string" }))
  .output(schema.projectMentionReplySelectSchema)
  .handler(async ({ context, input }) => {
    const { session } = context.session;
    if (!session.activeOrganizationId) {
      throw new ORPCError("BAD_REQUEST", { message: "Organization not found" });
    }
    const project = await getProjectById(
      input.projectId,
      session.activeOrganizationId,
    );
    if (!project.ok) {
      throw new ORPCError("BAD_REQUEST", { message: project.error.message });
    }
    const [row] = await context.db
      .update(schema.smProjectMentionReply)
      .set({ status: "approved" })
      .where(
        and(
          eq(schema.smProjectMentionReply.id, input.id),
          eq(schema.smProjectMentionReply.projectId, input.projectId),
        ),
      )
      .returning();
    // TODO: schedule Publish
    if (!row) {
      throw new ORPCError("BAD_REQUEST", { message: "Reply not found" });
    }
    return row;
  });

export default protectedBase
  .prefix("/project/{projectId}/mention/{mentionId}/reply")
  .router({ list, generate, approve });
