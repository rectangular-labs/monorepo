import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-arktype";
import { relations } from "drizzle-orm";
import {
  boolean,
  foreignKey,
  index,
  text,
  timestamp,
  uniqueIndex,
  uuid,
} from "drizzle-orm/pg-core";
import { timestamps, uuidv7 } from "../_helper";
import { pgMentionTable } from "../_table";
import { smKeyword } from "./keyword-schema";
import { smMention } from "./mention-schema";
import { smProjectKeywordMention } from "./project-keyword-mention-schema";
import { smProject } from "./project-schema";
import { smPrompt } from "./prompt-schema";

export const smProjectMentionReply = pgMentionTable(
  "project_mention_reply",
  {
    id: uuid().primaryKey().$defaultFn(uuidv7),
    projectId: uuid()
      .notNull()
      .references(() => smProject.id, {
        onDelete: "cascade",
        onUpdate: "cascade",
      }),
    mentionId: uuid()
      .notNull()
      .references(() => smMention.id, {
        onDelete: "cascade",
        onUpdate: "cascade",
      }),
    // Optional attribution to a specific match (keyword) that led to the reply
    attributedKeywordId: uuid()
      .notNull()
      .references(() => smKeyword.id, {
        onDelete: "cascade",
        onUpdate: "cascade",
      }),
    // Generation snapshot
    model: text(),
    promptOverrideId: uuid().references(() => smPrompt.id, {
      onDelete: "set null",
      onUpdate: "cascade",
    }),
    replyText: text(),
    isAutoGenerated: boolean().notNull().default(false),

    // Lifecycle
    status: text({
      enum: [
        "draft",
        "approved",
        "publishing",
        "published",
        "failed",
        "discarded",
      ],
    })
      .notNull()
      .default("draft"),
    error: text(),
    // Publish info
    providerPublishedId: text(),
    providerPublishedUrl: text(),
    publishedAt: timestamp({
      withTimezone: true,
      mode: "date",
    }),
    ...timestamps,
  },
  (table) => [
    // A project should only have one reply per mention
    uniqueIndex("sm_pmr_unique").on(table.projectId, table.mentionId),
    foreignKey({
      name: "sm_pmr_project_keyword_mention_fk",
      columns: [table.projectId, table.mentionId, table.attributedKeywordId],
      foreignColumns: [
        smProjectKeywordMention.projectId,
        smProjectKeywordMention.mentionId,
        smProjectKeywordMention.keywordId,
      ],
    }),
    index("sm_pmr_project_idx").on(table.projectId),
    index("sm_pmr_mention_idx").on(table.mentionId),
    index("sm_pmr_status_idx").on(table.status),
    index("sm_pmr_created_at_idx").on(table.createdAt),
  ],
);

export const smProjectMentionReplyRelations = relations(
  smProjectMentionReply,
  ({ one }) => ({
    project: one(smProject, {
      fields: [smProjectMentionReply.projectId],
      references: [smProject.id],
    }),
    mention: one(smMention, {
      fields: [smProjectMentionReply.mentionId],
      references: [smMention.id],
    }),
  }),
);

export const projectMentionReplyInsertSchema = createInsertSchema(
  smProjectMentionReply,
);
export const projectMentionReplyUpdateSchema = createUpdateSchema(
  smProjectMentionReply,
);
export const projectMentionReplySelectSchema = createSelectSchema(
  smProjectMentionReply,
);
