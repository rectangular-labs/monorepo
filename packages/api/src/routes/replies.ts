import { ORPCError } from "@orpc/client";
import { and, desc, eq, schema } from "@rectangular-labs/db";
import { type } from "arktype";
import { protectedBase } from "../context";
import { generateReply } from "../lib/ai";
import { getProjectById } from "../lib/database/project";
import { postRedditComment } from "../lib/reddit";

const statusUnion = type(
  "'draft'|'approved'|'publishing'|'published'|'failed'|'discarded'",
);

const list = protectedBase
  .route({ method: "GET", path: "/" })
  .input(type({ projectId: "string", mentionId: "string|undefined" }))
  .output(schema.replySelectSchema.array())
  .handler(async ({ context, input }) => {
    const { session } = context.session;
    if (!session.activeOrganizationId) {
      throw new ORPCError("BAD_REQUEST", { message: "Organization not found" });
    }
    const project = await getProjectById(
      input.projectId,
      session.activeOrganizationId,
    );
    if (!project.ok)
      throw new ORPCError("BAD_REQUEST", { message: project.error.message });
    const rows = await context.db.query.smReply.findMany({
      where: input.mentionId
        ? and(
            eq(schema.smReply.projectId, input.projectId),
            eq(schema.smReply.mentionId, input.mentionId),
          )
        : eq(schema.smReply.projectId, input.projectId),
      orderBy: desc(schema.smReply.createdAt),
    });
    return rows;
  });

const generate = protectedBase
  .route({ method: "POST", path: "/generate" })
  .input(
    type({
      projectId: "string",
      mentionId: "string",
      prompt: "string|undefined",
      model: "string|undefined",
    }),
  )
  .output(schema.replySelectSchema)
  .handler(async ({ context, input }) => {
    const { session } = context.session;
    if (!session.activeOrganizationId) {
      throw new ORPCError("BAD_REQUEST", { message: "Organization not found" });
    }
    const project = await getProjectById(
      input.projectId,
      session.activeOrganizationId,
    );
    if (!project.ok)
      throw new ORPCError("BAD_REQUEST", { message: project.error.message });
    const mention = await context.db.query.smMention.findFirst({
      columns: {
        id: true,
        content: true,
        title: true,
        providerMentionUrl: true,
      },
      where: and(
        eq(schema.smMention.id, input.mentionId),
        eq(schema.smMention.projectId, input.projectId),
      ),
    });
    if (!mention) throw new Error("Mention not found");

    const system =
      "You are an assistant generating concise, respectful replies for Reddit.";
    const prompt =
      input.prompt ??
      `Post: ${mention.title ?? ""}\n${mention.content ?? ""}\n\nWrite a helpful, on-topic reply.`;
    const text = await generateReply({ prompt, system, model: input.model });

    const [row] = await context.db
      .insert(schema.smReply)
      .values({
        projectId: input.projectId,
        mentionId: input.mentionId,
        model: input.model,
        replyText: text,
        isAutoGenerated: true,
      })
      .returning();
    if (!row) throw new Error("Reply not found");
    return row;
  });

const approve = protectedBase
  .route({ method: "POST", path: "/{id}/approve" })
  .input(type({ id: "string", projectId: "string" }))
  .output(schema.replySelectSchema)
  .handler(async ({ context, input }) => {
    const { session } = context.session;
    if (!session.activeOrganizationId) {
      throw new ORPCError("BAD_REQUEST", { message: "Organization not found" });
    }
    const project = await getProjectById(
      input.projectId,
      session.activeOrganizationId,
    );
    if (!project.ok)
      throw new ORPCError("BAD_REQUEST", { message: project.error.message });
    const [row] = await context.db
      .update(schema.smReply)
      .set({ status: "approved" })
      .where(
        and(
          eq(schema.smReply.id, input.id),
          eq(schema.smReply.projectId, input.projectId),
        ),
      )
      .returning();
    if (!row) throw new Error("Reply not found");
    return row;
  });

const publish = protectedBase
  .route({ method: "POST", path: "/{id}/publish" })
  .input(type({ id: "string", projectId: "string" }))
  .output(schema.replySelectSchema)
  .handler(async ({ context, input }) => {
    const { session } = context.session;
    if (!session.activeOrganizationId) {
      throw new ORPCError("BAD_REQUEST", { message: "Organization not found" });
    }
    const project = await getProjectById(
      input.projectId,
      session.activeOrganizationId,
    );
    if (!project.ok)
      throw new ORPCError("BAD_REQUEST", { message: project.error.message });
    const reply = await context.db.query.smReply.findFirst({
      where: and(
        eq(schema.smReply.id, input.id),
        eq(schema.smReply.projectId, input.projectId),
      ),
    });
    if (!reply) throw new Error("Reply not found");
    if (!reply.replyText) throw new Error("Reply text is empty");

    await context.db
      .update(schema.smReply)
      .set({ status: "publishing", error: null })
      .where(eq(schema.smReply.id, input.id));

    try {
      const mention = await context.db.query.smMention.findFirst({
        columns: { providerMentionId: true },
        where: and(
          eq(schema.smMention.id, reply.mentionId),
          eq(schema.smMention.projectId, reply.projectId),
        ),
      });
      if (!mention) throw new Error("Mention not found");

      const result = await postRedditComment(context.db, {
        parentFullname: `t3_${mention.providerMentionId}`,
        text: reply.replyText,
        userId: session.userId,
      });

      const [updated] = await context.db
        .update(schema.smReply)
        .set({
          status: "published",
          providerPublishedId: result.id,
          providerUrl: result.url,
          publishedAt: new Date(),
        })
        .where(eq(schema.smReply.id, input.id))
        .returning();
      if (!updated) throw new Error("Reply not found");
      return updated;
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      const [updated] = await context.db
        .update(schema.smReply)
        .set({ status: "failed", error: message })
        .where(eq(schema.smReply.id, input.id))
        .returning();
      if (!updated) throw new Error("Reply not found");
      return updated;
    }
  });

const setStatus = protectedBase
  .route({ method: "POST", path: "/{id}/status" })
  .input(type({ id: "string", projectId: "string", status: statusUnion }))
  .output(schema.replySelectSchema)
  .handler(async ({ context, input }) => {
    const { session } = context.session;
    if (!session.activeOrganizationId) {
      throw new ORPCError("BAD_REQUEST", { message: "Organization not found" });
    }
    const project = await getProjectById(
      input.projectId,
      session.activeOrganizationId,
    );
    if (!project.ok)
      throw new ORPCError("BAD_REQUEST", { message: project.error.message });
    const [row] = await context.db
      .update(schema.smReply)
      .set({ status: input.status })
      .where(
        and(
          eq(schema.smReply.id, input.id),
          eq(schema.smReply.projectId, input.projectId),
        ),
      )
      .returning();
    if (!row) throw new Error("Reply not found");
    return row;
  });

export default protectedBase
  .prefix("/replies")
  .router({ list, generate, approve, publish, setStatus });
